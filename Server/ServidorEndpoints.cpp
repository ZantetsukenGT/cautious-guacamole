// This file generated by ngrestcg
// For more information, please visit: https://github.com/loentar/ngrest

#include "ServidorEndpoints.h"

Arbol * estudiantes = new Arbol();
Horario * horarios_sistema = NULL;

std::string imagenText = "";

Estudiante * usuario_sesion_actual = NULL;

int YYYY_actual = 0;
std::string ciclo_actual = "NOT_SET";


///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
///////////////////////////////////////////METODOS DEL ESTUDIANTE//////////////////////////////////////////////
std::string ServidorEndpoints::GetEstudianteActual()
{
	return std::to_string(usuario_sesion_actual->Carnet);
}

std::string ServidorEndpoints::TieneImagen()
{
	if(usuario_sesion_actual->Imagen != NULL)
	{
		return "Si";
	}
	else
	{
		return "No";
	}
}

struct SesionSerial ServidorEndpoints::IniciarSesion(struct SesionSerial sesion)
{
	int criterio = std::stoi(sesion.usuario);
	NodoArbol * aux1 = *estudiantes->Buscar(criterio);
	if(aux1 != NULL)
	{
		Estudiante * aux = aux1->Get_Data();
		if(aux->Password == sesion.password)
		{
			usuario_sesion_actual = aux;
			return sesion;
		}
	}
	return {"NOT_FOUND","NOT_FOUND"};
}

std::string ServidorEndpoints::CerrarSesion()
{
	std::string result = "Se ha cerrado la sesion de: " + std::to_string(usuario_sesion_actual->Carnet);
	usuario_sesion_actual = NULL;
	return "Se ha cerrado sesion";
}






//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
//////////////////////////////////METODOS DEL SISTEMA/ADMINISTRADOR//////////////////////////////////////////////
std::string ServidorEndpoints::GetCicloActual()
{
	return ciclo_actual;
}

std::string ServidorEndpoints::SetCicloActual(std::string yyyy, std::string ciclo)
{
	YYYY_actual = std::stoi(yyyy);
	ciclo_actual = ciclo;

	Horario * aux = new Horario(YYYY_actual);
	horarios_sistema->Insertar(&horarios_sistema, aux);
	
	return "Se coloco: '" + ciclo_actual + "' del '" + std::to_string(YYYY_actual) + "' como ciclo actual del sistema";
}

std::string ServidorEndpoints::InsertarHorario(struct HorarioSerial nuevo)
{
	std::string result = "";
	Horario * aux = new Horario(std::stoi(nuevo.yyyy));
	aux = horarios_sistema->Insertar(&horarios_sistema, aux);

	if(nuevo.ciclo.compare("primer_semestre") == 0)
	{
		Version * aux2  = aux->primer_semestre->Buscar(nuevo.version);
		if(aux2 == NULL)
		{
			aux2 = new Version(nuevo.version);
			aux->primer_semestre->Insertar_Al_Frente(&aux->primer_semestre,aux2);
		}
	}
	else if(nuevo.ciclo.compare("segundo_semestre") == 0)
	{
		Version * aux2  = aux->segundo_semestre->Buscar(nuevo.version);
		if(aux2 == NULL)
		{
			aux2 = new Version(nuevo.version);
			aux->segundo_semestre->Insertar_Al_Frente(&aux->segundo_semestre,aux2);
		}
	}
	else if(nuevo.ciclo.compare("vacas_junio") == 0)
	{
		Version * aux2  = aux->vacas_junio->Buscar(nuevo.version);
		if(aux2 == NULL)
		{
			aux2 = new Version(nuevo.version);
			aux->vacas_junio->Insertar_Al_Frente(&aux->vacas_junio,aux2);
		}
	}
	else if(nuevo.ciclo.compare("vacas_diciembre") == 0)
	{
		Version * aux2  = aux->vacas_diciembre->Buscar(nuevo.version);
		if(aux2 == NULL)
		{
			aux2 = new Version(nuevo.version);
			aux->vacas_diciembre->Insertar_Al_Frente(&aux->vacas_diciembre,aux2);
		}
	}
	else
	{
		std::cout << nuevo.ciclo;
		result = "error extraño";
	}
	result = "Se inserto correctamente el horario con anyo: '" + nuevo.yyyy + "', ciclo: '" + nuevo.ciclo +"', y version: '" + nuevo.version + "'";
	return result;
}

std::string ServidorEndpoints::BuscarHorarios()
{
	std::string result = "";

	if(horarios_sistema != NULL)
	{
		Horario * pivote = horarios_sistema;
		do{
			if(pivote->siguiente != horarios_sistema)
			{
				result += std::to_string(pivote->YYYY) + "$";
			}
			else
			{
				result += std::to_string(pivote->YYYY);
			}
			pivote = pivote->siguiente;
		}
		while(pivote != horarios_sistema);
	}
	return result;
}

std::string ServidorEndpoints::BuscarCiclos(std::string yyyy)
{
	std::string result = "";

	if(horarios_sistema != NULL && yyyy != "")
	{
		Horario * pivote = horarios_sistema->Buscar(std::stoi(yyyy));
		if(pivote->primer_semestre != NULL)
		{
			if(pivote->segundo_semestre != NULL || pivote->vacas_junio != NULL || pivote->vacas_diciembre != NULL )
			{
				result += "primer_semestre$";
			}
			else
			{
				result += "primer_semestre";
			}
		}
		if(pivote->segundo_semestre != NULL)
		{
			if(pivote->vacas_junio != NULL || pivote->vacas_diciembre != NULL )
			{
				result += "segundo_semestre$";
			}
			else
			{
				result += "segundo_semestre";
			}
		}
		if(pivote->vacas_junio != NULL)
		{
			if(pivote->vacas_diciembre != NULL)
			{
				result += "vacas_junio$";
			}
			else
			{
				result += "vacas_junio";
			}
		}
		if(pivote->vacas_diciembre != NULL)
		{
			result += "vacas_diciembre";
		}
	}
	return result;
}

std::string ServidorEndpoints::BuscarVersiones(std::string yyyy, std::string ciclo)
{
	std::string result = "";

	if(horarios_sistema != NULL && yyyy != "" && ciclo != "")
	{
		Horario * pivote = horarios_sistema->Buscar(std::stoi(yyyy));
		if(ciclo.compare("primer_semestre") == 0)
		{
			Version * aux = pivote->primer_semestre;
			while(aux != NULL)
			{
				if(aux->siguiente != NULL)
				{
					result += aux->nombre_version + "$";
				}
				else
				{
					result += aux->nombre_version;
				}
				aux = aux->siguiente;
			}
		}
		else if(ciclo.compare("segundo_semestre") == 0)
		{
			Version * aux = pivote->segundo_semestre;
			while(aux != NULL)
			{
				if(aux->siguiente != NULL)
				{
					result += aux->nombre_version + "$";
				}
				else
				{
					result += aux->nombre_version;
				}
				aux = aux->siguiente;
			}
		}
		else if(ciclo.compare("vacas_junio") == 0)
		{
			Version * aux = pivote->vacas_junio;
			while(aux != NULL)
			{
				if(aux->siguiente != NULL)
				{
					result += aux->nombre_version + "$";
				}
				else
				{
					result += aux->nombre_version;
				}
				aux = aux->siguiente;
			}
		}
		else if(ciclo.compare("vacas_diciembre") == 0)
		{
			Version * aux = pivote->vacas_diciembre;
			while(aux != NULL)
			{
				if(aux->siguiente != NULL)
				{
					result += aux->nombre_version + "$";
				}
				else
				{
					result += aux->nombre_version;
				}
				aux = aux->siguiente;
			}
		}
		else
		{
			std::cout << ciclo;
			result = "error extraño";
		}
	}
	return result;
}

std::string ServidorEndpoints::VisualizarTodosHorarios()
{
	std::string result = "";
	std::string texto = "digraph G\n{\n\trankdir = LR;\n\tnode[shape=circle]; \n\n ";
	texto += "\tHorarios; \n\n ";
	Horario * pivote = horarios_sistema;
	if(horarios_sistema != NULL)
	{
		do{
			texto += "\tNodo" + std::to_string(pivote->YYYY) + "[label = \"" + std::to_string(pivote->YYYY) + "\"];\n";
			pivote = pivote->siguiente;
		}
		while(pivote != horarios_sistema);

		texto += "\n\tHorarios->";
		do{
			if(pivote->siguiente == horarios_sistema)
			{
				texto += "Nodo" + std::to_string(pivote->YYYY) + "->Nodo" + std::to_string(pivote->siguiente->YYYY) + ";\n";
			}
			else
			{
				texto += "Nodo" + std::to_string(pivote->YYYY) + "->";
			}
			pivote = pivote->siguiente;
		}
		while(pivote != horarios_sistema);
	}
	texto += "}";

	std::ofstream f;
	f.open("public/TodosHorarios.dot");
	f << texto;
	f.close();
	system("dot -Tpng public/TodosHorarios.dot -o public/TodosHorarios.png");
	result = "http://192.168.56.101:8080/TodosHorarios.png";
	return result;
}

std::string ServidorEndpoints::VisualizarCiclo(struct HorarioSerial ciclo)
{
	std::string result = "";
	Horario * aux = horarios_sistema->Buscar(std::stoi(ciclo.yyyy));
	Version * aux2 = NULL;
	std::string texto = "digraph G\n{\n\trankdir = LR;\n\tnode[shape=house]; \n\n ";
	texto += "\tCiclo";
	if(ciclo.ciclo.compare("primer_semestre") == 0)
	{
		texto += "[label = \"Primer Semestre";
		aux2 = aux->primer_semestre;
	}
	else if(ciclo.ciclo.compare("segundo_semestre") == 0)
	{
		texto += "[label = \"Segundo Semestre";
		aux2 = aux->segundo_semestre;
	}
	else if(ciclo.ciclo.compare("vacas_junio") == 0)
	{
		texto += "[label = \"Vacaciones Junio";
		aux2 = aux->vacas_junio;
	}
	else if(ciclo.ciclo.compare("vacas_diciembre") == 0)
	{
		texto += "[label = \"Vacaciones Diciembre";
		aux2 = aux->vacas_diciembre;
	}
	texto += "\n" + ciclo.yyyy + "\", shape = box];\n\t";
	int version = 0;
	int curso = 0;
	Version * pivote = aux2;
	if(pivote != NULL)
	{
		while(pivote != NULL)
		{
			texto += "\tVersion" + std::to_string(version++) + "[label = \"" + pivote->nombre_version + "\"];\n\t";
			pivote = pivote->siguiente;
		}
		texto += "Ciclo->";
		version = 0;
		pivote = aux2;
		while(pivote != NULL)
		{
			if(pivote->siguiente == NULL)
			{
				texto += "Version" + std::to_string(version++) + ";\n\n\t";
			}
			else
			{
				texto += "Version" + std::to_string(version++) + "->";
			}
			pivote = pivote->siguiente;
		}

		version = 0;
		pivote = aux2;
		while(pivote != NULL)
		{
			Curso * pivote2 = pivote->primero;
			texto += "subgraph GVersion" + std::to_string(version) + " {\n\t";
			texto += "rank = \"same\";\n";
			if(pivote2 != NULL)
			{
				int cursoPivote = curso;
				while(pivote2 != NULL)
				{
					texto += "\tCurso" + std::to_string(cursoPivote++) + "[label = \"" + std::to_string(pivote2->Codigo) + "\", shape = circle];\n";
					pivote2 = pivote2->siguiente;
				}
				pivote2 = pivote->primero;
				texto += "\n\tVersion" + std::to_string(version++) + "->";
				while(pivote2 != NULL)
				{
					if(pivote2->siguiente == NULL)
					{
						texto += "Curso" + std::to_string(curso++) + ";\n";
					}
					else
					{
						texto += "Curso" + std::to_string(curso++) + "->";
					}
					pivote2 = pivote2->siguiente;
				}
			}
			texto += "\t}\n";
			pivote = pivote->siguiente;
		}
	}
	texto += "}";

	std::ofstream f;
	f.open("public/Ciclo" + ciclo.yyyy + ciclo.ciclo + ".dot");
	f << texto;
	f.close();
	std::string cmd = "dot -Tpng public/Ciclo" + ciclo.yyyy + ciclo.ciclo + ".dot -o public/Ciclo" + ciclo.yyyy + ciclo.ciclo + ".png";
	system(cmd.c_str());
	result = "http://192.168.56.101:8080/Ciclo" + ciclo.yyyy + ciclo.ciclo + ".png";
	return result;
}

std::string ServidorEndpoints::VisualizarHorario(std::string buscado)
{
	std::string result = "";
	Horario * aux = horarios_sistema->Buscar(std::stoi(buscado));
	if(aux != NULL)
	{
		std::string texto = "digraph G\n{\n\trankdir = TB;\n\tnode[shape=box]; \n\n";
		texto += "\tHorario" + buscado + "[label = \"" + buscado +"\", shape=\"circle\"]; \n\t";
		texto += "Ciclo1S[label = \"Primer Semestre\"]; \n\t";
		texto += "Ciclo2S[label = \"Segundo Semestre\"]; \n\t";
		texto += "Ciclo1V[label = \"Vacaciones Junio\"]; \n\t";
		texto += "Ciclo2V[label = \"Vacaciones Diciembre\"]; \n\n\t";

		texto += "subgraph ciclos {\n";
		texto += "\tHorario" + buscado + "->Ciclo1S;\n";
		texto += "\tHorario" + buscado + "->Ciclo2S;\n";
		texto += "\tHorario" + buscado + "->Ciclo1V;\n";
		texto += "\tHorario" + buscado + "->Ciclo2V;\n";
		texto += "}\n\n\t";

		Version * aux2 = aux->primer_semestre;
		if(aux2 != NULL)
		{
			texto += "subgraph ciclo1 {\n\t";
			while(aux2 != NULL)
			{
				texto += "\t\"S1" + aux2->nombre_version + "\"[label = \"" + aux2->nombre_version + "\", shape = house];\n";
				aux2 = aux2->siguiente;
			}
			aux2 = aux->primer_semestre;
			texto += "\n\tCiclo1S->";
			while(aux2 != NULL)
			{
				if(aux2->siguiente != NULL)
				{
					texto += "\"S1" + aux2->nombre_version + "\"->";
				}
				else
				{
					texto += "\"S1" + aux2->nombre_version + "\";\n\n";
				}
				aux2 = aux2->siguiente;
			}
			texto += "}\n\n\t";
		}

		aux2 = aux->segundo_semestre;
		if(aux2 != NULL)
		{
			texto += "subgraph ciclo2 {\n\t";
			while(aux2 != NULL)
			{
				texto += "\t\"S2" + aux2->nombre_version + "\"[label = \"" + aux2->nombre_version + "\", shape = house];\n";
				aux2 = aux2->siguiente;
			}
			aux2 = aux->segundo_semestre;
			texto += "\n\tCiclo2S->";
			while(aux2 != NULL)
			{
				if(aux2->siguiente != NULL)
				{
					texto += "\"S2" + aux2->nombre_version + "\"->";
				}
				else
				{
					texto += "\"S2" + aux2->nombre_version + "\";\n\n";
				}
				aux2 = aux2->siguiente;
			}
			texto += "}\n\n\t";
		}

		aux2 = aux->vacas_junio;
		if(aux2 != NULL)
		{
			texto += "subgraph ciclo3 {\n\t";
			while(aux2 != NULL)
			{
				texto += "\t\"V1" + aux2->nombre_version + "\"[label = \"" + aux2->nombre_version + "\", shape = house];\n";
				aux2 = aux2->siguiente;
			}
			aux2 = aux->vacas_junio;
			texto += "\n\tCiclo1V->";
			while(aux2 != NULL)
			{
				if(aux2->siguiente != NULL)
				{
					texto += "\"V1" + aux2->nombre_version + "\"->";
				}
				else
				{
					texto += "\"V1" + aux2->nombre_version + "\";\n\n";
				}
				aux2 = aux2->siguiente;
			}
			texto += "}\n\n\t";
		}

		aux2 = aux->vacas_diciembre;
		if(aux2 != NULL)
		{
			texto += "subgraph ciclo4 {\n\t";
			while(aux2 != NULL)
			{
				texto += "\t\"V2" + aux2->nombre_version + "\"[label = \"" + aux2->nombre_version + "\", shape = house];\n";
				aux2 = aux2->siguiente;
			}
			aux2 = aux->vacas_diciembre;
			texto += "\n\tCiclo2V->";
			while(aux2 != NULL)
			{
				if(aux2->siguiente != NULL)
				{
					texto += "\"V2" + aux2->nombre_version + "\"->";
				}
				else
				{
					texto += "\"V2" + aux2->nombre_version + "\";\n\n";
				}
				aux2 = aux2->siguiente;
			}
			texto += "}\n\n\t";
		}
		texto += "}";

		std::ofstream f;
		f.open("public/Horario" + buscado + ".dot");
		f << texto;
		f.close();
		std::string cmd = "dot -Tpng public/Horario" + buscado + ".dot -o public/Horario" + buscado + ".png";
		system(cmd.c_str());
		result = "http://192.168.56.101:8080/Horario" + buscado + ".png";
	}
	else
	{
		result = "No se encontro el horario con año: " + buscado;
	}
	return result;
}

std::string ServidorEndpoints::BuscarHorario(std::string buscado)
{
	std::string result = "";
	Horario * aux = horarios_sistema->Buscar(std::stoi(buscado));
	if(aux != NULL)
	{
		result = "Se encontro correctamente el horario: " + buscado;
	}
	else
	{
		result = "No se encontro el horario con año: " + buscado;
	}
	return result;
}

std::string ServidorEndpoints::EliminarHorario(std::string eliminado)
{
	std::string result = "";
	Horario * aux = horarios_sistema->Remover(&horarios_sistema, std::stoi(eliminado));
	if(aux != NULL)
	{
		result = "Se elimino correctamente el horario: " + eliminado;
	}
	else
	{
		result = "No se encontro el horario con año: " + eliminado;
	}
	return result;
}

std::string ServidorEndpoints::InsertarCursoSistema(struct CursoSistemaSerial nuevo, struct HorarioSerial ciclo)
{
	std::string result = "";
	
	int codigo = std::stoi(nuevo.codigo);
    std::string nombre = nuevo.nombre;
    std::string seccion = nuevo.seccion;
    std::string edificio = nuevo.edificio;
    int salon = std::stoi(nuevo.salon);;
    std::string catedratico = nuevo.catedratico;
    std::vector<struct DiaSerial> horario = nuevo.horario;

	Curso * deserial = new Curso(codigo, nombre, seccion, edificio, salon, catedratico);
	for(int i = 0; i < (signed int) horario.size(); i++)
	{
		Dia * diaSerial = new Dia(horario.at(i).dia, horario.at(i).hora_in, horario.at(i).hora_fin);
		deserial->horario->Insertar_Al_Final(&deserial->horario, diaSerial);
	}

	Horario * aux = new Horario(std::stoi(ciclo.yyyy));
	aux = horarios_sistema->Insertar(&horarios_sistema, aux);

	if(ciclo.ciclo.compare("primer_semestre") == 0)
	{
		Version * aux2 = aux->primer_semestre->Buscar(ciclo.version);
		if(aux2 != NULL)
		{
			aux2->primero->Insertar(&aux2->primero, deserial);
		}
		else
		{
			aux2 = new Version(ciclo.version);
			aux2->primero->Insertar(&aux2->primero, deserial);
			aux->primer_semestre->Insertar_Al_Frente(&aux->primer_semestre, aux2);
		}
	}
	else if(ciclo.ciclo.compare("segundo_semestre") == 0)
	{
		Version * aux2 = aux->segundo_semestre->Buscar(ciclo.version);
		if(aux2 != NULL)
		{
			aux2->primero->Insertar(&aux2->primero, deserial);
		}
		else
		{
			aux2 = new Version(ciclo.version);
			aux2->primero->Insertar(&aux2->primero, deserial);
			aux->segundo_semestre->Insertar_Al_Frente(&aux->segundo_semestre, aux2);
		}
	}
	else if(ciclo.ciclo.compare("vacas_junio") == 0)
	{
		Version * aux2 = aux->vacas_junio->Buscar(ciclo.version);
		if(aux2 != NULL)
		{
			aux2->primero->Insertar(&aux2->primero, deserial);
		}
		else
		{
			aux2 = new Version(ciclo.version);
			aux2->primero->Insertar(&aux2->primero, deserial);
			aux->vacas_junio->Insertar_Al_Frente(&aux->vacas_junio, aux2);
		}
	}
	else if(ciclo.ciclo.compare("vacas_diciembre") == 0)
	{
		Version * aux2 = aux->vacas_diciembre->Buscar(ciclo.version);
		if(aux2 != NULL)
		{
			aux2->primero->Insertar(&aux2->primero, deserial);
		}
		else
		{
			aux2 = new Version(ciclo.version);
			aux2->primero->Insertar(&aux2->primero, deserial);
			aux->vacas_diciembre->Insertar_Al_Frente(&aux->vacas_diciembre, aux2);
		}
	}
	else
	{
		result = "error raro";
		return result;
	}

	result = "Curso: '" + nuevo.codigo + "': '" + nuevo.nombre + "', agregado en anyo: '";
	result += ciclo.yyyy + "', ciclo: '" + ciclo.ciclo + "', version: '" + ciclo.version + "'";
	return result;
}

std::string ServidorEndpoints::ModificarCursoSistema(struct CursoSistemaSerial nuevo, struct HorarioSerial ciclo,std::string viejo)
{
	std::string result = "";
	/**/
	return result;
}

struct CursoSistemaSerial ServidorEndpoints::BuscarCursoSistema(std::string buscado, struct HorarioSerial ciclo)
{
	struct CursoSistemaSerial result;
	Horario * aux = horarios_sistema->Buscar(std::stoi(ciclo.yyyy));
	Version * aux2 = NULL;
	Curso * aux3 = NULL;
	if(ciclo.ciclo.compare("primer_semestre") == 0)
	{
		aux2 = aux->primer_semestre->Buscar(ciclo.version);
		aux3 = aux2->primero->Buscar(std::stoi(buscado));
	}
	else if(ciclo.ciclo.compare("segundo_semestre") == 0)
	{
		aux2 = aux->segundo_semestre->Buscar(ciclo.version);
		aux3 = aux2->primero->Buscar(std::stoi(buscado));
	}
	else if(ciclo.ciclo.compare("vacas_junio") == 0)
	{
		aux2 = aux->vacas_junio->Buscar(ciclo.version);
		aux3 = aux2->primero->Buscar(std::stoi(buscado));
	}
	else if(ciclo.ciclo.compare("vacas_diciembre") == 0)
	{
		aux2 = aux->vacas_diciembre->Buscar(ciclo.version);
		aux3 = aux2->primero->Buscar(std::stoi(buscado));
	}

	if(aux3 != NULL)
	{
		result.codigo = std::to_string(aux3->Codigo);
		result.nombre = aux3->Nombre;
		result.seccion = aux3->Seccion;
		result.edificio = aux3->Edificio;
		result.salon = std::to_string(aux3->Salon);
		result.catedratico = aux3->Catedratico;

		std::vector<struct DiaSerial> horario;
		Dia * aux4 = aux3->horario;
		while(aux4 != NULL)
		{
			struct DiaSerial nuevo;

			nuevo.dia = aux4->nombre;
			nuevo.hora_in = aux4->HH_inicio;
			nuevo.hora_fin = aux4->HH_fin;

			horario.push_back(nuevo);
			aux4 = aux4->siguiente;
		}
		result.horario = horario;
	}
	else
	{
		result.codigo = "NOT_FOUND";
		result.nombre = "";
		result.seccion = "";
		result.edificio = "";
		result.salon = "";
		result.catedratico = "";
		result.horario = {{"","",""},{"","",""}};
	}

	return result;
}

std::string ServidorEndpoints::EliminarCursoSistema(std::string eliminado, struct HorarioSerial ciclo)
{
	std::string result = "";
	Horario * aux = horarios_sistema->Buscar(std::stoi(ciclo.yyyy));
	Version * aux2 = NULL;
	Curso * aux3 = NULL;
	if(ciclo.ciclo.compare("primer_semestre") == 0)
	{
		aux2 = aux->primer_semestre->Buscar(ciclo.version);
		aux3 = aux2->primero->Remover(&aux2->primero, std::stoi(eliminado));
	}
	else if(ciclo.ciclo.compare("segundo_semestre") == 0)
	{
		aux2 = aux->segundo_semestre->Buscar(ciclo.version);
		aux3 = aux2->primero->Remover(&aux2->primero, std::stoi(eliminado));
	}
	else if(ciclo.ciclo.compare("vacas_junio") == 0)
	{
		aux2 = aux->vacas_junio->Buscar(ciclo.version);
		aux3 = aux2->primero->Remover(&aux2->primero, std::stoi(eliminado));
	}
	else if(ciclo.ciclo.compare("vacas_diciembre") == 0)
	{
		aux2 = aux->vacas_diciembre->Buscar(ciclo.version);
		aux3 = aux2->primero->Remover(&aux2->primero, std::stoi(eliminado));
	}

	if(aux3 != NULL)
	{
		result = "Curso con codigo: '" + eliminado + "', en año: '" + ciclo.yyyy + "', ciclo: '"; 
		result += ciclo.ciclo + "', version: '" + ciclo.version + "' eliminado con exito";
	}
	else
	{
		result = "No existe curso con codigo: '" + eliminado + "', en año: '" + ciclo.yyyy + "', ciclo: '"; 
		result += ciclo.ciclo + "', version: '" + ciclo.version + "' para eliminar";
	}
	return result;
}

std::string ServidorEndpoints::VisualizarCursoSistema(std::string visualizado, struct HorarioSerial ciclo)
{
	std::string result = "";
	Horario * aux = horarios_sistema->Buscar(std::stoi(ciclo.yyyy));
	if(aux != NULL)
	{
		std::string texto = "digraph G\n{\n\trankdir = TB;\n\tnode[shape=box]; \n\n";
		Curso * aux3 = NULL;
		if(ciclo.ciclo.compare("primer_semestre") == 0)
		{
			Version * aux2 = aux->primer_semestre->Buscar(ciclo.version);
			aux3 = aux2->primero->Buscar(std::stoi(visualizado));
		}
		else if(ciclo.ciclo.compare("segundo_semestre") == 0)
		{
			Version * aux2 = aux->segundo_semestre->Buscar(ciclo.version);
			aux3 = aux2->primero->Buscar(std::stoi(visualizado));
		}
		else if(ciclo.ciclo.compare("vacas_junio") == 0)
		{
			Version * aux2 = aux->vacas_junio->Buscar(ciclo.version);
			aux3 = aux2->primero->Buscar(std::stoi(visualizado));
		}
		else if(ciclo.ciclo.compare("vacas_diciembre") == 0)
		{
			Version * aux2 = aux->vacas_diciembre->Buscar(ciclo.version);
			aux3 = aux2->primero->Buscar(std::stoi(visualizado));
		}
		texto += "\tCurso[label = \"Codigo del curso: " + std::to_string(aux3->Codigo) + ",\n";
		texto += "Nombre: " + aux3->Nombre + ",\n";
		texto += "Seccion: " +  aux3->Seccion + ",\n";
		texto += "Edificio: " +  aux3->Edificio + ",\n";
		texto += "Salon: " +  std::to_string(aux3->Salon) + ",\n";
		texto += "Catedratico: " +  aux3->Catedratico + ",\n\n";
		texto += "Horario:\n";
		Dia * aux4 = aux3->horario;
		while(aux4 != NULL)
		{
			texto += aux4->nombre +", " + aux4->HH_inicio + " - " + aux4->HH_fin + "\n";
			aux4 = aux4->siguiente;
		}
		texto += "\"];\n";
		texto += "}";

		std::ofstream f;
		f.open("public/Curso" + visualizado + ".dot");
		f << texto;
		f.close();
		std::string cmd = "dot -Tpng public/Curso" + visualizado + ".dot -o public/Curso" + visualizado + ".png";
		system(cmd.c_str());
		result = "http://192.168.56.101:8080/Curso" + visualizado + ".png";
	}
	else
	{
		result = "No se encontro el horario con año: " + visualizado;
	}
	return result;
}

std::string ServidorEndpoints::InsertarEstudiante(struct EstudianteSerial nuevo)
{
	std::string result = "";
	Esencial * a = new Esencial();
	int * fecha = a->SplitFecha(nuevo.fechaNacimiento);

	Estudiante * deserial = new Estudiante(std::stoi(nuevo.carne), std::stoi(nuevo.dpi), nuevo.nombre,
                       nuevo.apellidos, fecha[0], fecha[1],
                       fecha[2], nuevo.direccion, std::stoi(nuevo.creditos),
                       NULL, nuevo.password, NULL);
	if(estudiantes->Insertar(deserial))
		result = "Se inserto correctamente el estudiante con carnet: " + nuevo.carne;
	else
		result = "Estudiante con carnet repetido no insertado: " + nuevo.carne;
	return result;
}

struct EstudianteSerial ServidorEndpoints::BuscarEstudiante(std::string usuario)
{	
	int criterio = std::stoi(usuario);
	NodoArbol * aux1 = *estudiantes->Buscar(criterio);
	struct EstudianteSerial res;
	if(aux1 != NULL)
	{
		Estudiante * aux = aux1->Get_Data();
		res.carne = std::to_string(aux->Carnet);
		res.dpi = std::to_string(aux->DPI);
		res.nombre = aux->Nombres;
		res.apellidos = aux->Apellidos;
		res.fechaNacimiento = std::to_string(aux->DD_Nacimiento) + "/" + std::to_string(aux->MM_Nacimiento) + "/" + std::to_string(aux->YYYY_Nacimiento);
		res.direccion = aux->Direccion;
		res.creditos = std::to_string(aux->Creditos);
		res.password = aux->Password;
	}
	else
	{
		res.carne = "NOT_FOUND";
		res.dpi = "NOT_FOUND";
		res.nombre = "NOT_FOUND";
		res.apellidos = "NOT_FOUND";
		res.fechaNacimiento = "NOT_FOUND";
		res.direccion = "NOT_FOUND";
		res.creditos = "NOT_FOUND";
		res.password = "NOT_FOUND";
	}
	return res;
}

std::string ServidorEndpoints::ModificarEstudiante(struct EstudianteSerial nuevo, std::string viejo)
{	
	std::string result = "";
	int criterio = std::stoi(viejo);
	Esencial * a = new Esencial();
	int * fecha = a->SplitFecha(nuevo.fechaNacimiento);

	Estudiante * deserial = new Estudiante(std::stoi(nuevo.carne), std::stoi(nuevo.dpi), nuevo.nombre,
                       nuevo.apellidos, fecha[0], fecha[1],
                       fecha[2], nuevo.direccion, std::stoi(nuevo.creditos),
                       NULL, nuevo.password, NULL);
	estudiantes->Modificar(deserial,criterio);
	result = "Se modifico correctamente el estudiante con carnet original: " + viejo;
	return result;
}

std::string ServidorEndpoints::EliminarEstudiante(std::string eliminar)
{	
	std::string result = "";
	int criterio = std::stoi(eliminar);

	estudiantes->Remover(criterio);
	result = "Se elimino correctamente el estudiante con carnet: " + eliminar;
	return result;
}

std::string ServidorEndpoints::VisualizarEstudiante(std::string visualizado)
{
	std::string result = "";
	NodoArbol * aux1 = *estudiantes->Buscar(std::stoi(visualizado));
	if(aux1 != NULL)
	{
		Estudiante * aux = aux1->Get_Data();
		std::string texto = "digraph G\n{\n\trankdir = TB;\n\tnode[shape=box]; \n\n";
		
		texto += "\tEstudiante[label = \"Carnet: " + std::to_string(aux->Carnet) + ",\n";
		texto += "DPI: " + std::to_string(aux->DPI) + ",\n";
		texto += "Nombres: " +  aux->Nombres + ",\n";
		texto += "Apellidos: " +  aux->Apellidos + ",\n";
		texto += "Fecha de Nacimiento: " + std::to_string(aux->DD_Nacimiento) + "/";
		texto += std::to_string(aux->MM_Nacimiento) + "/";
		texto += std::to_string(aux->YYYY_Nacimiento) + ",\n";
		texto += "Direccion: " +  aux->Direccion + ",\n";
		texto += "Creditos: " + std::to_string(aux->Creditos) + ",\n";
		texto += "Password: " + aux->Password + ",\n";;
		texto += "Tiene Imagen: ";
		if(aux->Imagen != NULL)
		{
			texto += "Si\n";
		}
		else {
			texto += "No\n";
		}
		texto += "Tiene Horarios: ";
		if(aux->horarios != NULL)
		{
			texto += "Si";
		}
		else {
			texto += "No";
		}
		texto += "\"];\n";
		texto += "}";

		std::ofstream f;
		f.open("public/Estudiante" + visualizado + ".dot");
		f << texto;
		f.close();
		std::string cmd = "dot -Tpng public/Estudiante" + visualizado + ".dot -o public/Estudiante" + visualizado + ".png";
		system(cmd.c_str());
		result = "http://192.168.56.101:8080/Estudiante" + visualizado + ".png";
	}
	else
	{
		result = "No se encontro el estudiante con carne: " + visualizado;
	}
	return result;
}

std::string ServidorEndpoints::SetContrasena(struct SesionSerial sesion)
{
	int criterio = std::stoi(sesion.usuario);
	std::string result = "";
	NodoArbol * aux1 = *estudiantes->Buscar(criterio);
	if(aux1 != NULL)
	{
		Estudiante * aux = aux1->Get_Data();
		aux->Password = sesion.password;
		result = "Password de: " + std::to_string(criterio) + ", seteada con exito";
		return result;
	}
	result = "No se pudo setear password de: " + std::to_string(criterio) + ", el usuario no existe";
	return result;
}

std::string ServidorEndpoints::GraficarArbol()
{
	std::string texto = "digraph G { rankdir = TB; node[shape=circle]; \n\n ";
	texto+= estudiantes->PreOrderFormat();
	texto+= "\n\n";
	texto+= estudiantes->PreOrderLink();
	texto+= "} ";

	std::ofstream f;
	f.open("public/Arbol.dot");
	f << texto;
	f.close();
    system("dot -Tpng public/Arbol.dot -o public/Arbol.png");
	std::string a = "http://192.168.56.101:8080/Arbol.png";
	return a;
}

std::string ServidorEndpoints::SetLineaImagen(std::string text)
{
	imagenText += text + "\n";
	std::string result = "Se leen aprox 50,000 lineas";
	return result;
}

std::string ServidorEndpoints::GenerarMatriz(std::string usuario)
{
	int criterio = std::stoi(usuario);
	std::string result = "";
	MatrizDispersa *m1 = new MatrizDispersa();
	int x;
	int y;

	int estado = 0;
	std::string token = "";
	bool error = false;
	bool aceptacion = true;

	for(int i = 0; error == false && i < (signed int)imagenText.length(); i++)
	{
		char actual = imagenText.at(i);
		switch(estado)
		{
			case 0:
				if ((int) actual == 10 || (int) actual == 13 || (int) actual == 9 || (int) actual == 32)
				{
					token = "";
					estado = 0;
					aceptacion = true;
				}
				else if((int) actual >= 48 && (int) actual <= 57)
				{
					token.push_back(actual);
					estado = 1;
					aceptacion = false;
				}
				else
				{
					error = true;
				}
			break;
			case 1:
				if((int) actual >= 48 && (int) actual <= 57)
				{
					token.push_back(actual);
				}
				else if((int) actual == 44)
				{
					x = std::stoi(token);
					token = "";
					estado = 2;
				}
				else
				{
					error = true;
				}
			break;
			case 2:
				if((int) actual >= 48 && (int) actual <= 57)
				{
					token.push_back(actual);
					estado = 3;
				}
				else
				{
					error = true;
				}
			break;
			case 3:
				if((int) actual >= 48 && (int) actual <= 57)
				{
					token.push_back(actual);
				}
				else if((int) actual == 58)
				{
					y = std::stoi(token);
					token = "";
					estado = 4;
				}
				else
				{
					error = true;
				}
			break;
			case 4:
				if((int) actual == 35)
				{
					estado = 5;
				}
				else
				{
					error = true;
				}
			break;
			case 5:
				if(	((int) actual >= 48 && (int) actual <= 57) ||
					((int) actual >= 65 && (int) actual <= 70) ||
					((int) actual >= 97 && (int) actual <= 102))
				{
					token.push_back(actual);
					estado = 6;
				}
				else
				{
					error = true;
				}
			break;
			case 6:
				if(	((int) actual >= 48 && (int) actual <= 57) ||
					((int) actual >= 65 && (int) actual <= 70) ||
					((int) actual >= 97 && (int) actual <= 102))
				{
					token.push_back(actual);
					estado = 7;
				}
				else
				{
					error = true;
				}
			break;
			case 7:
				if(	((int) actual >= 48 && (int) actual <= 57) ||
					((int) actual >= 65 && (int) actual <= 70) ||
					((int) actual >= 97 && (int) actual <= 102))
				{
					token.push_back(actual);
					estado = 8;
				}
				else
				{
					error = true;
				}
			break;
			case 8:
				if(	((int) actual >= 48 && (int) actual <= 57) ||
					((int) actual >= 65 && (int) actual <= 70) ||
					((int) actual >= 97 && (int) actual <= 102))
				{
					token.push_back(actual);
					estado = 9;
				}
				else
				{
					error = true;
				}
			break;
			case 9:
				if(	((int) actual >= 48 && (int) actual <= 57) ||
					((int) actual >= 65 && (int) actual <= 70) ||
					((int) actual >= 97 && (int) actual <= 102))
				{
					token.push_back(actual);
					estado = 10;
				}
				else
				{
					error = true;
				}
			break;
            case 10:
                if(	((int) actual >= 48 && (int) actual <= 57) ||
                    ((int) actual >= 65 && (int) actual <= 70) ||
                    ((int) actual >= 97 && (int) actual <= 102))
                {
                    token.push_back(actual);
                    estado = 11;
                    aceptacion = false;
                    if(i == (signed) imagenText.length() - 1)
                    {
                        m1->Insertar(y,x,token);
                        token = "";
                        aceptacion = true;
                    }
                }
                else
                {
                    error = true;
                }
            break;
            case 11:
                if ((int) actual == 10 || (int) actual == 13 || (int) actual == 9 || (int) actual == 32)
                {
                    m1->Insertar(y,x,token);
                    token = "";
                    estado = 0;
                    aceptacion = true;
                }
                else
                {
                    error = true;
                }
            break;
		}
	}
	imagenText = "";
	if(error == false && aceptacion == true)
	{
		result = "http://192.168.56.101:8080/" + m1->GenerarGrafo(criterio);
		if(criterio >= 0)
		{
			NodoArbol * aux1 = *estudiantes->Buscar(criterio);
			Estudiante * aux = aux1->Get_Data();
			aux->Imagen = m1;
		}
		return result;
	}
	result = "Archivo de imagen mal construido";
	return result;
}